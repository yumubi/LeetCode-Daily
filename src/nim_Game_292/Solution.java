package src.nim_Game_292;

public class Solution {


    /**
     * 当起始局面石子数量为 4 的倍数，则先手必败，否则先手必胜（即 n % 4 != 0 时，先手必胜）。
     * 然后我们通过「归纳法」证明一下该猜想的正确性。
     * 在上面的「找规律」分析中，我们分情况讨论了最后一个决胜回合（我们称「剩余石子数量少于等于 4 的局面」为最后回合）的情况：
     * 如果交由先手的石子数量为 4，那么先手必败，否则先手必胜。
     * 而对于「最后回合」前的任意回合（石子数量大于 4），我们需要证明 先手可以通过调整所选石子数量，来维持「n % 4 != 0」直到最后回合。
     * 如果起始对先手而言满足「n % 4 != 0」，此时先手可以通过选择石子数量为「n % 4」来确保交到后手的局面为 4 的倍数。
     * 那么根据推论，此时的原始后手作为下一回合的先手角色，且面临石子数量为 4的倍数的局面，为必败态。
     * 进一步的解释就是，由于原始后手面临石子数量为 4 的倍数的局面，且只能选 1 - 3个石子，因此无论如何选择，重新回到原始先手的仍然满足「n % 4 != 0」（非 4 的倍数）。
     * 因此 原始先手只需要确保每次都选择「x % 4」个石子（x 为当前石子数量），
     * 就可以确保交由自己的局面一直满足「x % 4 != 0」，交由对方的局面一直满足「x % 4 == 0」，直到最后回合的到来。
     * 至此，我们证明了 如果起始石子数量 n 满足「n % 4 != 0」条件，那么先手必胜。
     * @param n
     * @return
     */
    public boolean canWinNim(int n) {
       return n % 4 != 0;
    }


    //巴什博弈 只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个。最后取光者得胜。
    // 只要 n 不能整除 m+1 ,那么必然是先手取胜，否则后手取胜


    // TODO: 22/11/2022 孙笑川我的大哥
    /**
     * 换一个角度看，不把它当成数学题的话，这个题是博弈型动态规划的很好的入门题。
     * 首先从第一步开始分析，对于当前先手来说：
     * 如果剩余的石头为0，则当前先手必败。
     * 如果剩余石头为1-3，则当前先手必胜。
     * 但现在有n个石头，如何判断先手是必胜还是必败？其实画个图很容易分析：
     * 当前先手对应n个石头，后手就对应n-1、n-2、n-3三种集合的石头
     * 每个集合一定都会对应必胜或者必败
     * 因此可以得到这样一个递推关系：
     * 只有当n-1、n-2、n-3三种集合都必胜时，n对应的集合才必败。因为不管n走哪条路，都一定对应着后手必胜，也就是对应着先手必败。
     * 而但凡后手对应的n-1、n-2、n-3三种集合有一种对应的是必败，先手都一定是必胜。因为玩家是绝对聪明的，一定会走让后手必败的路线。
     *
     * 因此可以得到状态转移方程：
     * f(n) = !(f(n-1) && f(n-2) && f(n-3))
     * f(0) = false
     * @param n
     * @return
     */
    public boolean canWinNim2(int n) {
        boolean[] dp = new boolean[4];
        for(int i = 1; i <= n; i++) {
            boolean ret = true;
            ret &= dp[(i - 1) % 4];
            if(i >= 2) ret &= dp[(i - 2) % 4];
            if(i >= 3) ret &= dp[(i - 3) % 4];
            dp[i % 4] = !ret;
        }
        return dp[n % 4];
    }

    //最开始从递归入手，写出下面代码

    //class Solution {
    //public:
    //    bool canWinNim(int n) {
    //        if(n <= 0) {
    //            return false;
    //        }
    //        if(n <= 3) {
    //            return true;
    //        }
    //        return !canWinNim(n-1) || !canWinNim(n-2) || !canWinNim(n-3);
    //    }
    //};

    //然后考虑dp，写出下面代码
    //class Solution {
    //public:
    //    bool canWinNim(int n) {
    //        vector<bool> dp(n, true);
    //        for(int i = 4; i <= n; ++i) {
    //            dp[i-1] = !dp[i-2] || !dp[i-3] || !dp[i-4];
    //        }
    //        return dp[n-1];
    //    }
    //};
//滚动数组


        public boolean canWinNim4(int n) {
            if (n <= 3) {
                return true;
            }

            boolean[] dp = new boolean[4];
            dp[0] = false;
            dp[1] = true;
            dp[2] = true;
            dp[3] = true;
            for (int i = 4; i <= n; i++) {
                dp[i % 4] = !dp[(i - 1) % 4] || !dp[(i - 2) % 4] || !dp[(i - 3) % 4];
            }
            return dp[n % 4];
        }








}
